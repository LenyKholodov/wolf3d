#ifndef __VESA_LO_H__
#define __VESA_LO_H__

#include <vstypes.h>
#include <vgalo.h>

#ifdef __386__
	#define VESAInfoStructRMptr 	ulong
	#define VESAModeInfoStructRMptr ulong
	#define VOID_RMptr		ulong
	#define RGBQUADRMptr		ulong
#else
	#define VESAInfoStructRMptr 	VESAInfoStruct far*
	#define VESAModeInfoStructRMptr VESAModeInfoStruct far*
	#define VOID_RMptr		void far*
	#define RGBQUADRMptr		RGBQUAD far*
#endif

/*************************************************************************
*     возвращает информацию о версии VESA и производителе видеоплаты.    *
*  ничего не инициализирует!!! (на то и lo)                              *
*************************************************************************/
int VESALOinfo(VESAInfoStructRMptr);
/*************************************************************************
* возвращает информацию о конкретном видеорежиме. Она выдает расширенную *
* информацию о каждом режиме из списка, возвращаемого функцией 0.        *
* Требует выделения 256-байтного блока.	      	       		 	 *
*************************************************************************/
int VESALOModeInfo(VESAModeInfoStructRMptr,int);

/***************************************************************************
* Функция 2 устанавливает видеорежим.                                      *
* mode- номер видеорежима и ряд флагов:                                    *
*        D0-D8 - номер режима;                                             *
*        D9-D13 - зарезервировано (должно быть 0);                         *
*        D14 = 0 - использовать оконный режим;                             *
*                = 1 - использовать режим LFB;                             *
*        D15 = 0 - очищать видеопамять;                                    *
*                = 1 - не очищать видеопамять.                             *
***************************************************************************/
int VESALOSetMode(int mode);
/***************************************************************************
* 	Функция 3 возвращает текущий видеорежим.                           *
***************************************************************************/
int VESALOGetMode(void);

/***************************************************************************
* Функция сохраняет/восстанавливает состояние.    			   *
* D0 - состояние оборудования контроллера;                                 *
* D1 - состояние данных BIOS;                                              *
* D2 - состояние регистров DAC;                                            *
* D3 - состояние расширенных регистров;                                    *
***************************************************************************/
#define VESA_SW_ADAPTER	0xD0
#define VESA_SW_BIOS	0xD1
#define VESA_SW_DAC	0xD2
#define VESA_SW_EXT	0xD3
ulong VESALOSaveStructSize(int area);
int VESALOSave(int area,VOID_RMptr addr);
int VESALORestore(int area,VOID_RMptr addr);

/***************************************************************************
* Функция 5 управляет экранным окном. Она позволяет переместить окно, через*
* которое процессор обращается к различным участкам видеопамяти, а также   *
* узнать, в котором положении установлено текущее окно. 	  	   *
***************************************************************************/
int VESALOSetBank(int bank,int win);
int VESALOGetBank(int win);

/***************************************************************************
* Функция 6 управляет логической длиной строки. Она позволяет изменить 	   *
* логическую длину строки, что может понадобиться для реализации 	   *
* горизонтального скроллинга, а также узнать текущую длину строки. Сам 	   *
* горизонтальный скроллинг, так же как вертикальный, управляется функцией 7*
* Hа входе:                                                                *
* BL = 0 - установить длину строки (в точках растра);                      *
*        = 1 - возвратить длину строки;                                    *
*        = 2 - установить длину строки (в байтах);                         *
*        = 3 - возвратить максимальную длину строки;                       *
* CX - длина строки в указанных в BL единицах (при установке).             *
* Hа выходе:                                                               *
* AX - статус завершения;                                                  *
* BX - количество байт в строке;                                           *
* CX - длина строки в точках растра;                                       *
* DX - максимальный номер строки растра.                                   *
* Функции BL = 2 и BL = 3 были добавлены в версию 2.0.                     *
* Вследствие аппаратных ограничений запрошенный размер строки может не     *
* поддерживаться, и тогда устанавливается его ближайшее большее значение.  *
* Эта функция доступна и в текстовых режимах, причем в них длина строки    *
* задается не в символах, а в точках растра. Для этого длину строки в 	   *
* символах надо умножить на размер знакоместа в точках, возвращаемый 	   *
* функцией 1. Если задать длину строки, не кратную размеру знакоместа, то  *
* это приведет к ошибке. При слишком большой длине строки функция      	   *
* возвращает код ошибки, равный 2.                                         *
***************************************************************************/
int VESALOLineWidth(int w,int mode,VESALineWidthInfo* lwi);

/***************************************************************************
* Функция 7 управляет положением экранного окна в видеопамяти. Она 	   *
* устанавливает, какой адрес видеопамяти будет отображаться в точку в 	   *
* верхнем левом углу, а также позволяет переключать экранные страницы и    *
* осуществлять вертикальный скроллинг, а при превышении логической ширины  *
* экрана над отображаемой - горизонтальный.                                *
* Возможность производить установку во время вертикального обратного хода  *
* луча появилась только в версии 2.0. Эта функция поддерживается также в   *
* текстовых режимах. В этом случае в регистры заносится произведение номера*
* строки или столбца на соответствующий размер знакоместа.                 *
***************************************************************************/
int VESALOSetWinPos(int x,int y,BOOL wRefresh=FALSE);
int VESALOGetWinPos(int* x,int* y);

/***************************************************************************
* Функция 8 управляет форматом DAC палитры. Она позволяет управлять 	   *
* разрядностью цвета в регистрах палитры, если это поддерживается аппаратно*
* (см. информационный блок поле Capabilities). По умолчанию в этих 	   *
* регистрах на каждый цвет отводится по шесть бит.                         *
* Если запрошенная разрядность цвета не может быть установлена, будет 	   *
* установлена ближайшая доступная, а ее величина будет возвращена  	   *
***************************************************************************/
int VESALOGetDAC(void);
int VESALOSetDAC(int d);

/***************************************************************************
* 	Стандарт VBE 2.0 вводит две новые функции.                         *
* Hа входе:                                                                *
* BL = 00h - установить данные палитры;                                    *
*    = 01h - возвратить данные палитры;                                    *
*    = 02h - установить данные дополнительной палитры;                     *
*    = 03h - возвратить данные дополнительной палитры;                     *
*    = 80h - установить данные палитры во время импульса                   *
* обратного хода луча;                                                     *
* ES:DI - адрес таблицы данных для регистров палитры.                      *
***************************************************************************/
int VESALOPalette(int fn,int start,int count,RGBQUADRMptr addr);

/***************************************************************************
* 	Функция 0Ah запрашивает интерфейс защищенного режима. 		   *
* Она возвращает указатель на таблицу, содержащую адреса функций 	   *
* 32-разрядного защищенного режима для функций 5, 7 и 9, а также таблицу   *
* портов и используемых участков памяти. Функции защищенного режима можно  *
* либо скопировать в новый кодовый сегмент (для чего возвращается также    *
* длина кода), либо вызывать непосредственно из ПЗУ.                       *
* Формат таблицы следующий:                                                *
* ES : DI + 00h - смещение точки входа функции 5;                          *
* ES : DI + 02h - смещение точки входа функции 7;                          *
* ES : DI + 04h - смещение точки входа функции 9;                          *
* ES : DI + 06h - смещение таблицы портов и участков памяти.               *
*                                                                          *
* Все смещения даются относительно адреса начала таблицы.                  *
* Следует отметить, что формат параметров функции 7 защищенного режима	   *
* несколько отличается от такового для реального режима. При вызове 	   *
* 32-разрядной функции в регистре CX следует передавать младшее слово 	   *
* полного 32-разрядного смещения от начала видеопамяти, а в DX - старшее.  *
***************************************************************************/
int VESALOAddr32(VOID_RMptr *addr,int* len);

#endif