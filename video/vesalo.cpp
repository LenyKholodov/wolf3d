#include <vesalo.h>

#ifdef __386__
	#include <dpmi32gw.h>
	#define VESA_ROK(rg)	(rg.w.ax==0x004F)
	#define DECLARE_RMR(x)  RMREGS x;memset(&x,0,sizeof(RMREGS)); 
	#define RMInt(i,r)	DPMIRMInt(i,r)
	#define W_REG(regs)	regs.w
#else
	#include <dos.h>
	#define VESA_ROK(rg)	(rg.x.ax==0x004F)
	#define DECLARE_RMR(x)  union REGS x;
	#define RMInt(i,r)	int86(i,r,r)
	#define W_REG(regs)	regs.x
#endif

/***************************************************************************
* Функция 0 возвращает информацию о версии VESA и производителе видеоплаты.*
* Перед ее вызовом необходимо выделить в нижней памяти буфер длиной 256б   *
* В версии 2.0 функция позволяет получить некоторую дополнительную  	   *
* информацию, если в первые четыре байта выделенного буфера предварительно *
* записать 4-байтную сигнатуру "VBE2". При этом размер буфера должен 	   *
* составлять 512 байт.                                                     *
* Hа входе:                                                                *
* AX = 4F00h;                                                              *
* ES:DI - указатель на буфер,                                              *
*        в который надо поместить информацию,                              *
*        в формате сегмент:смещение                                        *
*        (обратите внимание: именно сегмент                                *
*        реального режима, а не селектор защищенного).                     *
* Hа выходе:                                                               *
* AX - статус завершения.                                                  *
***************************************************************************/
int VESALOinfo(VESAInfoStructRMptr rmaddr)
{
	DECLARE_RMR(regs);
	W_REG(regs).ax=0x4F00;
#ifdef __386__
        regs.w.es=hiword(rmaddr);
        regs.x.edi=loword(rmaddr);
	RMInt(0x10,&regs);
#else
        struct SREGS seg_regs;
        seg_regs.es=FP_SEG(rmaddr);
        regs.x.di=FP_OFF(rmaddr);
	int86x(0x10,&regs,&regs,&seg_regs);
#endif
	return VESA_ROK(regs);
}

/***************************************************************************
*   Функция 1 возвращает информацию о конкретном видеорежиме. Она выдает   *
* расширенную информацию о каждом режиме из списка, возвращаемого          *
* функцией 0. Требует выделения 256-байтного блока.                        *
* Hа входе:                                                                *
* AX = 4F01h;                                                              *
* CX - номер видеорежима;                                                  *
* ES:DI - указатель на буфер,                                              *
*     в который надо поместить информацию,                                 *
*     в формате сегмент:смещение.                                          *
* Hа выходе:                                                               *
* AX - статус завершения.                                                  *
***************************************************************************/
int VESALOModeInfo(VESAModeInfoStructRMptr rmaddr,int mode)
{
	DECLARE_RMR(regs);
	W_REG(regs).ax=0x4F01;
	W_REG(regs).cx=mode;
#ifdef __386__
        regs.w.es=hiword(rmaddr);
        regs.x.edi=loword(rmaddr);
	RMInt(0x10,&regs);
#else
        struct SREGS sregs;
        sregs.es=FP_SEG(rmaddr);
        regs.x.di=FP_OFF(rmaddr);
	int86x(0x10,&regs,&regs,&sregs);
#endif
	return VESA_ROK(regs);
}

/***************************************************************************
* Функция 2 устанавливает видеорежим.                                      *
* Hа входе:                                                                *
* AX = 4F02h;                                                              *
* BX - номер видеорежима и ряд флагов:                                     *
*        D0-D8 - номер режима;                                             *
*        D9-D13 - зарезервировано (должно быть 0);                         *
*        D14 = 0 - использовать оконный режим;                             *
*                = 1 - использовать режим LFB;                             *
*        D15 = 0 - очищать видеопамять;                                    *
*                = 1 - не очищать видеопамять.                             *
* Hа выходе:                                                               *
* AX - статус завершения.                                                  *
***************************************************************************/
int VESALOSetMode(int mode)
{
	DECLARE_RMR(regs);
	W_REG(regs).ax=0x4F02;
	W_REG(regs).bx=mode;
	RMInt(0x10,&regs);
	return VESA_ROK(regs);
}

/***************************************************************************
* 	Функция 3 возвращает текущий видеорежим.                           *
* Hа входе:                                                                *
* AX = 4F03h.                                                              *
* Hа выходе:                                                               *
* BX - номер текущего видеорежима, включая флаги.                          *
***************************************************************************/
int VESALOGetMode(void)
{
	DECLARE_RMR(regs);
	W_REG(regs).ax=0x4F03;
	RMInt(0x10,&regs);
        return W_REG(regs).bx;
}

/***************************************************************************
* Функция 4 сохраняет/восстанавливает состояние. Она является развитием    *
* функции 1Ch прерывания 10h. Ее введение вызвано необходимостью сохранять *
* и восстанавливать состояние расширенных регистров.                       *
* Hа входе:                                                                *
* AX = 4F04h;                                                              *
* DL = 0 - возвратить длину буфера сохранения;                             *
*    = 1 - сохранить состояние;                                            *
*    = 2 - восстановить состояние;                                         *
* CX - характеристика состояния:                                           *
* D0 - состояние оборудования контроллера;                                 *
* D1 - состояние данных BIOS;                                              *
* D2 - состояние регистров DAC;                                            *
* D3 - состояние расширенных регистров;                                    *
* ES:BX - указатель на буфер при ненулевом DL.                             *
* Hа выходе:                                                               *
* AX - статус завершения;                                                  *
* BX - длина буфера для сохранения состояния в 64-байтных блоках(при DL=0).*
* Функция, естественно, не сохраняет содержимое видеопамяти.               *
***************************************************************************/
ulong VESALOSaveStructSize(int area)
{
	DECLARE_RMR(regs);
	regs.h.dl=0;
	W_REG(regs).ax=0x4F04;
	W_REG(regs).cx=area;
	RMInt(0x10,&regs);
       	return VESA_ROK(regs)?ulong(W_REG(regs).bx)*64:0;
}

int VESALOSave(int area,VOID_RMptr addr)
{
	DECLARE_RMR(regs);
	regs.h.dl=1;
        W_REG(regs).ax=0x4F04;
	W_REG(regs).cx=area;
#ifdef __386__
        regs.w.es=hiword(addr);
        regs.x.ebx=loword(addr);
	RMInt(0x10,&regs);
#else
        struct SREGS sregs;
        sregs.es=FP_SEG(addr);
        regs.x.bx=FP_OFF(addr);
	int86x(0x10,&regs,&regs,&sregs);
#endif
	return VESA_ROK(regs);
}

int VESALORestore(int area,VOID_RMptr addr)
{
	DECLARE_RMR(regs);
	regs.h.dl=2;
	W_REG(regs).ax=0x4F04;
	W_REG(regs).cx=area;
#ifdef __386__
        regs.w.es=hiword(addr);
        regs.x.ebx=loword(addr);
	RMInt(0x10,&regs);
#else
        struct SREGS sregs;
        sregs.es=FP_SEG(addr);
        regs.x.bx=FP_OFF(addr);
	int86x(0x10,&regs,&regs,&sregs);
#endif
	return VESA_ROK(regs);
}

/***************************************************************************
* Функция 5 управляет экранным окном. Она позволяет переместить окно, через*
* которое процессор обращается к различным участкам видеопамяти, а также   *
* узнать, в котором положении установлено текущее окно. Для повышения 	   *
* производительности эта функция может быть вызвана напрямую по адресу,    *
* возвращаемому функцией 1.                                                *
* Hа входе:      AX = 4F05h;                                               *
* BH = 0 - функция установки положения окна;                               *
*        = 1 - функция запроса положения окна;                             *
* BL = 0 - окно А;                                                         *
*        = 1 - окно В;                                                     *
* DX - положение окна в видеопамяти                                        *
*        (при BH = 0).                                                     *
* Hа выходе:                                                               *
* AX - статус завершения;                                                  *
* DX - положение окна (при BH = 1).                                        *
***************************************************************************/
int VESALOSetBank(int bank,int win)
{
	DECLARE_RMR(regs);
	regs.h.bh=0;
	regs.h.bl=win;
	W_REG(regs).ax=0x4F05;
	W_REG(regs).dx=bank;
	RMInt(0x10,&regs);
	return VESA_ROK(regs);
}

int VESALOGetBank(int win)
{
	DECLARE_RMR(regs);
	regs.h.bh=1;
	regs.h.bl=win;
        W_REG(regs).ax=0x4F05;
	RMInt(0x10,&regs);
       	return VESA_ROK(regs)?W_REG(regs).dx:-1;
}

/***************************************************************************
* Функция 6 управляет логической длиной строки. Она позволяет изменить 	   *
* логическую длину строки, что может понадобиться для реализации 	   *
* горизонтального скроллинга, а также узнать текущую длину строки. Сам 	   *
* горизонтальный скроллинг, так же как вертикальный, управляется функцией 7*
* Hа входе:                                                                *
* AX = 4F06h;                                                              *
* BL = 0 - установить длину строки (в точках растра);                      *
*        = 1 - возвратить длину строки;                                    *
*        = 2 - установить длину строки (в байтах);                         *
*        = 3 - возвратить максимальную длину строки;                       *
* CX - длина строки в указанных в BL единицах (при установке).             *
* Hа выходе:                                                               *
* AX - статус завершения;                                                  *
* BX - количество байт в строке;                                           *
* CX - длина строки в точках растра;                                       *
* DX - максимальный номер строки растра.                                   *
* Функции BL = 2 и BL = 3 были добавлены в версию 2.0.                     *
* Вследствие аппаратных ограничений запрошенный размер строки может не     *
* поддерживаться, и тогда устанавливается его ближайшее большее значение.  *
* Эта функция доступна и в текстовых режимах, причем в них длина строки    *
* задается не в символах, а в точках растра. Для этого длину строки в 	   *
* символах надо умножить на размер знакоместа в точках, возвращаемый 	   *
* функцией 1. Если задать длину строки, не кратную размеру знакоместа, то  *
* это приведет к ошибке. При слишком большой длине строки функция      	   *
* возвращает код ошибки, равный 2.                                         *
***************************************************************************/
int VESALOLineWidth(int w,int mode,VESALineWidthInfo* lwi)
{
	DECLARE_RMR(regs);
	regs.h.bl=mode;
	W_REG(regs).ax=0x4F06;
	W_REG(regs).cx=w;
	RMInt(0x10,&regs);
	lwi->bCount=W_REG(regs).bx;
	lwi->pCount=W_REG(regs).cx;
	lwi->MaxNumber=W_REG(regs).dx;
	return VESA_ROK(regs);
}

/***************************************************************************
* Функция 7 управляет положением экранного окна в видеопамяти. Она 	   *
* устанавливает, какой адрес видеопамяти будет отображаться в точку в 	   *
* верхнем левом углу, а также позволяет переключать экранные страницы и    *
* осуществлять вертикальный скроллинг, а при превышении логической ширины  *
* экрана над отображаемой - горизонтальный.                                *
* Hа входе:                                                                *
* AX = 4F07h;                                                              *
* BX = 0 - установить положение экранного окна;                            *
*        = 1 - возвратить положение экранного окна;                        *
*        = 80h - производить установку во время импульса вертикального     *
*	       обратного хода;                                             *
* CX - номер первой отображаемой точки в строке (при установке);           *
* DX - номер первой отображаемой строки растра (при установке).            *
* Hа выходе:                                                               *
* AX - статус завершения;                                                  *
* CX - номер первой отображаемой точки в строке (при запросе);             *
* DX - номер первой отображаемой строки растра (при запросе).              *
* Возможность производить установку во время вертикального обратного хода  *
* луча появилась только в версии 2.0. Эта функция поддерживается также в   *
* текстовых режимах. В этом случае в регистры заносится произведение номера*
* строки или столбца на соответствующий размер знакоместа.                 *
***************************************************************************/
int VESALOSetWinPos(int x,int y,BOOL wRefresh)
{
	DECLARE_RMR(regs);
	W_REG(regs).ax=0x4F07;
	W_REG(regs).bx=wRefresh?0x80:0;
	W_REG(regs).cx=x;
	W_REG(regs).dx=y;
	RMInt(0x10,&regs);
	return VESA_ROK(regs);
}

int VESALOGetWinPos(int* x,int* y)
{
	DECLARE_RMR(regs);
	W_REG(regs).ax=0x4F07;
	W_REG(regs).bx=1;
	RMInt(0x10,&regs);
	*x=W_REG(regs).cx;
	*y=W_REG(regs).dx;
	return VESA_ROK(regs);
}

/***************************************************************************
* Функция 8 управляет форматом DAC палитры. Она позволяет управлять 	   *
* разрядностью цвета в регистрах палитры, если это поддерживается аппаратно*
* (см. информационный блок поле Capabilities). По умолчанию в этих 	   *
* регистрах на каждый цвет отводится по шесть бит.                         *
* Hа входе:                                                                *
* AX = 4F08h;                                                              *
* BL = 0 - установить разрядность DAC палитры;                             *
*        = 1 - возвратить разрядность DAC палитры;                         *
* BH - требуемое число разрядов на основной цвет                           *
* (при установке).                                                         *
* Hа выходе:                                                               *
* AX - статус завершения;                                                  *
* BH - количество разрядов, приходящееся на основной цвет.                 *
* Если запрошенная разрядность цвета не может быть установлена, будет 	   *
* установлена ближайшая доступная, а ее величина будет возвращена в 	   *
* регистре BH.                                                             *
***************************************************************************/
int VESALOGetDAC(void)
{
	DECLARE_RMR(regs);
	regs.h.bl=1;
	W_REG(regs).ax=0x4F08;
	RMInt(0x10,&regs);
	return VESA_ROK(regs)?regs.h.bh:0;
}

int VESALOSetDAC(int d)
{
	DECLARE_RMR(regs);
	regs.h.bl=0;
	regs.h.bh=d;
	W_REG(regs).ax=0x4F08;
	RMInt(0x10,&regs);
        return regs.h.bh;
}

/***************************************************************************
* 	Стандарт VBE 2.0 вводит две новые функции.                         *
* Функция 9 управляет данными регистров палитры. Функция 8, введенная 	   *
* предыдущей версией стандарта, позволяла изменить разрядность регистров   *
* палитры, но ничего не говорила о том, как с ними следует работать. 	   *
* Функция 9 восполняет этот пробел и заменяет собой стандартные подфункции *
* 12h и 17h работы с палитрой функции 10h прерывания 10h.		   *
* Hа входе:                                                                *
* AX = 4F09h,                                                              *
* BL = 00h - установить данные палитры;                                    *
*    = 01h - возвратить данные палитры;                                    *
*    = 02h - установить данные дополнительной палитры;                     *
*    = 03h - возвратить данные дополнительной палитры;                     *
*    = 80h - установить данные палитры во время импульса                   *
* обратного хода луча;                                                     *
* CX - количество изменяемых цветов палитры;                               *
* DX - номер первого из изменяемых цветов;                                 *
* ES:DI - адрес таблицы данных для регистров палитры.                      *
* Hа выходе:                                                               *
* AX - статус завершения.                                                  *
***************************************************************************/
int VESALOPalette(int fn,int start,int count,RGBQUADRMptr addr)
{
	DECLARE_RMR(regs);
	W_REG(regs).ax=0x4F09;
	regs.h.bl=fn;
	W_REG(regs).cx=count;
	W_REG(regs).dx=start;
#ifdef __386__
        regs.w.es=hiword(addr);
        regs.w.di=loword(addr);
	RMInt(0x10,&regs);
#else
        struct SREGS sregs;
        sregs.es=FP_SEG(addr);
        regs.x.di=FP_OFF(addr);
	int86x(0x10,&regs,&regs,&sregs);
#endif
	return VESA_ROK(regs);
}

/***************************************************************************
* 	Функция 0Ah запрашивает интерфейс защищенного режима. 		   *
* Она возвращает указатель на таблицу, содержащую адреса функций 	   *
* 32-разрядного защищенного режима для функций 5, 7 и 9, а также таблицу   *
* портов и используемых участков памяти. Функции защищенного режима можно  *
* либо скопировать в новый кодовый сегмент, либо вызывать непосредственно  *
* Hа входе:                                                                *
* AX = 4F0Ah;                                                              *
* BL = 00h.                                                                *
* Hа выходе:                                                               *
* AX - статус завершения;                                                  *
* ES - сегмент таблицы в адресации реального режима;                       *
* DI - смещение таблицы;                                                   *
* CX - длина таблицы, включая длину кода.                                  *
* Формат таблицы следующий:                                                *
* ES : DI + 00h - смещение точки входа функции 5;                          *
* ES : DI + 02h - смещение точки входа функции 7;                          *
* ES : DI + 04h - смещение точки входа функции 9;                          *
* ES : DI + 06h - смещение таблицы портов и участков памяти.               *
* Все смещения даются относительно адреса начала таблицы.                  *
* Следует отметить, что формат параметров функции 7 защищенного режима	   *
* несколько отличается от такового для реального режима. При вызове 	   *
* 32-разрядной функции в регистре CX следует передавать младшее слово 	   *
* полного 32-разрядного смещения от начала видеопамяти, а в DX - старшее.  *
***************************************************************************/
int VESALOAddr32(VOID_RMptr *addr,int* len)
{
	DECLARE_RMR(regs);
        W_REG(regs).ax=0x4F0A;
	regs.h.bl=0;
#ifdef __386__
	RMInt(0x10,&regs);
	*addr=MakeDword(regs.w.es,regs.w.di);
#else
        struct SREGS sregs;
	int86x(0x10,&regs,&regs,&sregs);
	*addr=MK_FP(sregs.es,regs.x.di);
#endif
	*len=W_REG(regs).cx;
	return VESA_ROK(regs);
}